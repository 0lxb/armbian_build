#!/bin/bash
#
# armbianmonitor
#
# This script serves different purposes based on how it is called:
#
# - toggle boot verbosity (works)
# - monitoring mode: continually print monitoring info (WiP)
# - uploading /var/log/armhwinfo.log to online pastebin service
#
# Without arguments called it should present a simple user
# interface that guides through:
#
# - installation of RPi-Monitor if not already installed by user
# - active basic or more verbose monitoring mode
# - provides monitoring parameters for connected disks
#
# The second part is WiP and all the user interaction part
# still completely missing.
#
# This script is used to configure armbianmonitor behaviour.
# It will ask the user whether to activate monitoring or not,
# whether to enable debug monitoring and also how to deal with
# connected disks. In fact it walks through the list of available
# disks, checks them, tries to patch hddtemp.db if necessary
# and provides a proposal for /etc/armbianmonitor/disks.conf
# when a new disk is found.
#
# In case monitoring should be activated the following file 
# will be created: /etc/armbianmonitor/start-monitoring. If 
# debug output has been chosen, then DEBUG will be written to 
# the file.
#
# The script will install smartmontools/gdisk if not already
# installed and patches smartmontools' update-smart-drivedb 
# script if necessary. For disks the 'device model' will be
# shown but internally we rely always on the GUID. This is the
# key for entry in /etc/armbianmonitor/disks.conf
#
# When the script exits and the user activated monitoring it
# recommends doing a restart since on the next reboot the
# setup-armbian-monitoring-environment script will configure 
# monitoring sources and decides based on the existence and 
# contents of /etc/armbianmonitor/start-monitoring whether 
# rpimonitord should be started or not.
#
# The format of /etc/armbianmonitor/disks.conf is as follows:
#
# ${GUID}:${Name}:${smartctl prefix}:${temp call}:${CRC}:${LCC}
#
# Two examples:
#
# A57BF307-7D82-4783-BD1D-B346CA8C195B:WD Green::199:193 # WD HDD on SATA
# F8D372DC-63DB-494B-B802-87DC47FAD4E1:Samsung EVO:sat::199: # SSD in USB enclosure
#
# - GUID is the GUID as determined by gdisk
# - 'Name': The name as it will later be shown in RPi-Monitor, defaults to 
#   the 'device model' read out through smartctl but can be changed to
#   be more significant (beware that this string must contain colons!)
# - "smartctl prefix" can be empty or should be the the necessary prefix for 
#   USB disks, eg. '-d sat' or '-d usbjmicron' and so on -- please have a 
#   look at https://www.smartmontools.org/wiki/Supported_USB-Devices
# - "temp call" when being omitted indicates that hddtemp should be used. 
#   Otherwise it should contain the complete command line ('DISK' will be 
#   dynamically replaced by the device node when the actual monitoring 
#   happens), for example:
#   /sbin/hdparm -C DISK | egrep -q "standby|sleeping" || /usr/sbin/smartctl -d sat -a DISK | awk -F" " '/Temperature_Cel/ {printf $10}'
# - 'CRC attribute': The decimal value of the S.M.A.R.T. attribute that
#   is used to store the count of checksum errors between disk and host 
#   controller (might be omitted if the drive doesn't support it)
# - 'LCC attribute': The decimal value of the S.M.A.R.T. attribute that 
#   should contain the load cycle counter value (might be omitted
#   if the drive doesn't support it)
#
# TODO:
#
# - develop main functionality ;) asking the user regarding monitoring
# - deal with 'SMART overall-health self-assessment test result:'
# - write documentation
#
############################################################################

Main() {
	export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

	# check if stdout is a terminal...
	if test -t 1; then
		# see if it supports colors...
		ncolors=$(tput colors)
		if test -n "$ncolors" && test $ncolors -ge 8; then
			BOLD="$(tput bold)"
			NC='\033[0m' # No Color
			LGREEN='\033[1;32m'
			LRED='\e[0;91m'
		fi
	fi
	
	[ $# -eq 0 ] && (DisplayUsage ; exit 0)
	
	ParseOptions "$@"

	exit 0
	PreRequisits
	
	# check whether user runs rpimonitord on his own or we activated it
	if [ -f /etc/armbianmonitor/start-monitoring ]; then
		# we should already provide monitoring, check whether DEBUG
		# is also set
		ArmbianMonitoring=TRUE
		read DebugMode </etc/armbianmonitor/start-monitoring 2>/dev/null
	fi
	
	# check whether rpimonitord is running and compare with ${ArmbianMonitoring}
	# In case the user chose to run rpimonitord on his own, we skip the config
	# part and only output disk info
	:
	
	# check available disk devices
	CheckDisks
} # Main

ParseOptions() {
	while getopts 'hHbBuUrRmMdDc:C:pP' c ; do
	case ${c} in
		H)
			# display full help test
			# export FullUsage=TRUE
			DisplayUsage
			exit 0
			;;
		h)
			# display short help
			DisplayUsage
			exit 0
			;;
		b|B)
			# toggle boot verbosity
			if [ -f /boot/.force-verbose ]; then
				rm /boot/.force-verbose
				echo -e "Verbose kernel messages have been disabled. Please reboot for changes to take effect."
			else
				date "+%s" >/boot/.force-verbose
				chmod 666 /boot/.force-verbose
				echo -e "Verbose kernel messages have been enabled. Please reboot for changes to take effect."
			fi
			exit 0
			;;
		m|M)
			# monitoring mode
			echo -e "Stop monitoring using [ctrl]-[c]"
			MonitorMode ${OPTARG}
			exit 0
			;;
		u|U)
			# Upload /var/log/armhwinfo.log to be of help in support forum.
			fping sprunge.us | grep -q alive || \
				(echo "Network/firewall problem detected. Please fix this or upload /var/log/armhwinfo.log manually." >&2 ; exit 1)
			which curl >/dev/null 2>&1 || apt-get -f -qq -y install curl
			echo -e "/var/log/armhwinfo.log has been uploaded to \c"
			# we obfuscate IPv4 addresses somehow but not too much, MAC addresses have to remain
			# in clear since otherwise the log becomes worthless due to randomly generated 
			# addresses here and there that might conflict
			CollectSupportInfo \
				| sed -E 's/([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3})/XXX.XXX.\3\4/g' \
				| curl -F 'sprunge=<-' http://sprunge.us
			echo -e "Please post the URL in the Armbian forum where you've been asked for."
			exit 0
			;;
		r|R)
			# Installs RPi-Monitor and patches config on sun8i
			fping armbian.com | grep -q alive || \
				(echo "Network/firewall problem detected. Please fix this prior to installing RPi-Monitor." >&2 ; exit 1)
			InstallRPiMonitor
			case $(awk '/Hardware/ {print $3$4}' </proc/cpuinfo) in
				*sun8i*)
					PatchRPiMonitor_for_sun8i
					case $(uname -r) in
						3.4.*)
							sed -i 's|H3_Extended_Mainline.conf|H3_Extended.conf|' /etc/rpimonitor/template/OrangePi_H3.conf
							systemctl restart rpimonitor >/dev/null 2>&1
							;;
					esac
					;;
			esac
			echo -e "\nNow you're able to enjoy RPi-Monitor at http://$((ifconfig -a) | sed -n '/inet addr/s/.*addr.\([^ ]*\) .*/\1/p' | head -1):8888"
			exit 0
			;;
		p|P)
			# Installs cpuminer
			fping armbian.com | grep -q alive || \
				(echo "Network/firewall problem detected. Please fix this prior to installing cpuminer." >&2 ; exit 1)
			cd /usr/local/src/
			wget http://downloads.sourceforge.net/project/cpuminer/pooler-cpuminer-2.4.5.tar.gz
			tar xf pooler-cpuminer-2.4.5.tar.gz && rm pooler-cpuminer-2.4.5.tar.gz
			cd cpuminer-2.4.5/
			apt-get -f -qq -y install libcurl4-gnutls-dev
			./configure CFLAGS="-O3 -mfpu=neon"
			make && make install
			echo -e "\n\nNow you can use /usr/local/bin/minerd to do automated benchmarking.\nIn case you also installed RPi-Monitor you can do a"
			echo -e "\n    touch /root/.cpuminer\n\nto ensure minerd is running after reboot and results are recorded\nwith RPi-Monitor"
			exit 0
			;;
		d|D)
			fping sprunge.us | grep -q alive || \
				(echo "Network/firewall problem detected. Please fix this prior to installing RPi-Monitor." >&2 ; exit 1)
			DebugOutput="$(mktemp /tmp/${0##*/}.XXXXXX)"
			trap "rm \"${DebugOutput}\" ; exit 0" 0 1 2 3 15
			set -x
			exec 2>"${DebugOutput}"
			PreRequisits >/dev/null 2>&1
			CheckDisks
			which curl >/dev/null 2>&1 || apt-get -f -qq -y install curl
			echo -e "\nDebug output has been collected at the following URL: \c"
			(cat "${DebugOutput}"; echo -e "\n\n\ngdisk.txt contents:\n" ; cat "${MyTempDir}/gdisk.txt" ;\
				echo -e "\n\n\nsmartctl.txt contents:\n" ; cat "${MyTempDir}/smartctl.txt") \
				| curl -F 'sprunge=<-' http://sprunge.us
			echo -e "Please post the URL in the Armbian forum where you've been asked for."
			exit 0			
			;;
		c|C)
			# check card mode
			CheckCard "${OPTARG}"
			exit 0
			;;
	esac
	done
} # ParseOptions

DisplayUsage() {
	echo -e "Usage: ${BOLD}${0##*/} [-h] [-b] [-c \$path] [-d] [-m] [-p] [-r] [-u]${NC}\n"
	echo -e "############################################################################"
	if [ ${FullUsage} ]; then
		echo -e "\nDetailed Description:"
		grep "^#" "$0" | grep -v "^#\!/bin/bash" | sed 's/^#//'
	fi
	echo -e "\n Use ${BOLD}armbianmonitor${NC} for the following tasks:\n"
	echo -e " armbianmonitor ${BOLD}-b${NC} switches between verbose and normal boot"
	echo -e " armbianmonitor ${BOLD}-c /path/to/test${NC} performs disk health/performance tests"
	echo -e " armbianmonitor ${BOLD}-d${NC} tries to upload debug disk info to improve armbianmonitor"
	echo -e " armbianmonitor ${BOLD}-m${NC} provides simple CLI monitoring"
	echo -e " armbianmonitor ${BOLD}-p${NC} installs cpuminder for performance measurements"
	echo -e " armbianmonitor ${BOLD}-r${NC} tries to install RPi-Monitor"
	echo -e " armbianmonitor ${BOLD}-u${NC} tries to upload armhwinfo.log for support purposes\n"
	echo -e "############################################################################\n"
} # DisplayUsage

MonitorMode() {
	# $1 is the time in seconds to pause between two prints, defaults to 5 seconds
	# This functions prints out endlessly:
	# - time/date
	# - average 1m load
	# - detailed CPU statistics
	# - Soc temperature if available
	# - PMIC temperature if available
	# TODO: Format output nicely
	LastUserStat=0
	LastNiceStat=0
	LastSystemStat=0
	LastIdleStat=0
	LastIOWaitStat=0
	LastIrqStat=0
	LastSoftIrqStat=0
	LastCpuStatCheck=0

	Sensors="/etc/armbianmonitor/datasources/"
	echo -e "Time        CPU    load %cpu %sys %usr %nice %io %irq\c"
	[ -f "${Sensors}/soctemp" ] && echo -e "   CPU\c"
	[ -f "${Sensors}/pmictemp" ] && echo -e "   PMIC\c"
	while true ; do
		LoadAvg=$(cut -f1 -d" " </proc/loadavg)
		CpuFreq=$(awk '{printf ("%0.0f",$1/1000); }' </sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq)
		echo -e "\n$(date "+%H:%M:%S"): $(printf "%4s" ${CpuFreq})MHz $(printf "%5s" ${LoadAvg}) $(ProcessStats)\c"
		if [ -f "${Sensors}/soctemp" ]; then
			read SocTemp <"${Sensors}/soctemp"
			if [ ${SocTemp} -ge 1000 ]; then
				SocTemp=$(awk '{printf ("%0.1f",$1/1000); }' <"${Sensors}/soctemp")
			fi
			echo -e " $(printf "%4s" ${SocTemp})°C\c"
		fi
		[ -f "${Sensors}/pmictemp" ] && \
			(PMICTemp=$(awk '{printf ("%0.1f",$1/1000); }' <"${Sensors}/pmictemp") ; echo -e " $(printf "%4s" ${PMICTemp})°C\c")
		sleep ${1:-5}
	done
} # MonitorMode

ProcessStats() {
	if [ -f /tmp/cpustat ]; then
		# RPi-Monitor/Armbianmonitor already running and providing processed values
		set $(awk -F" " '{print $1"\t"$2"\t"$3"\t"$4"\t"$5"\t"$6}' </tmp/cpustat)
		CPULoad=$1
		SystemLoad=$2
		UserLoad=$3
		NiceLoad=$4
		IOWaitLoad=$5
		IrqCombinedLoad=$6		
	else
		set $(awk -F" " '/^cpu / {print $2"\t"$3"\t"$4"\t"$5"\t"$6"\t"$7"\t"$8}' </proc/stat)
		UserStat=$1
		NiceStat=$2
		SystemStat=$3
		IdleStat=$4
		IOWaitStat=$5
		IrqStat=$6
		SoftIrqStat=$7
		
		UserDiff=$(( ${UserStat} - ${LastUserStat} ))
		NiceDiff=$(( ${NiceStat} - ${LastNiceStat} ))
		SystemDiff=$(( ${SystemStat} - ${LastSystemStat} ))
		IdleDiff=$(( ${IdleStat} - ${LastIdleStat} ))
		IOWaitDiff=$(( ${IOWaitStat} - ${LastIOWaitStat} ))
		IrqDiff=$(( ${IrqStat} - ${LastIrqStat} ))
		SoftIrqDiff=$(( ${SoftIrqStat} - ${LastSoftIrqStat} ))
		
		Total=$(( ${UserDiff} + ${NiceDiff} + ${SystemDiff} + ${IdleDiff} + ${IOWaitDiff} + ${IrqDiff} + ${SoftIrqDiff} ))
		CPULoad=$(( ( ${Total} - ${IdleDiff} ) * 100 / ${Total} ))
		UserLoad=$(( ${UserDiff} *100 / ${Total} ))
		SystemLoad=$(( ${SystemDiff} *100 / ${Total} ))
		NiceLoad=$(( ${NiceDiff} *100 / ${Total} ))
		IOWaitLoad=$(( ${IOWaitDiff} *100 / ${Total} ))
		IrqCombinedLoad=$(( ( ${IrqDiff} + ${SoftIrqDiff} ) *100 / ${Total} ))

		LastUserStat=${UserStat}
		LastNiceStat=${NiceStat}
		LastSystemStat=${SystemStat}
		LastIdleStat=${IdleStat}
		LastIOWaitStat=${IOWaitStat}
		LastIrqStat=${IrqStat}
		LastSoftIrqStat=${SoftIrqStat}
	fi
	echo -e "$(printf "%3s" ${CPULoad})%$(printf "%4s" ${SystemLoad})%$(printf "%4s" ${UserLoad})%$(printf "%4s" ${NiceLoad})%$(printf "%4s" ${IOWaitLoad})%$(printf "%4s" ${IrqCombinedLoad})%"

} # ProcessStats

CheckDisks() {
	# This function walks through all block devices whose name starts with sd* and
	# then gets the name hddtemp expects, the model name from smartctl, looks whether
	# the drive only lists one temperature value and patches hddtemp.db if necessary
	# and also tries to get CRC and LCC S.M.A.R.T. attributes to provide the user
	# with the necessary config file contents for /etc/armbianmonitor/disks.conf:
	
	ls /sys/block/sd* >/dev/null 2>&1 || exit 0
	
	for i in /sys/block/sd* ; do
		DeviceNode=/dev/${i##*/}
		# get GUID/UUID for disk and check whether a partition table is existent. If
		# not GUID will always be random
		gdisk -l ${DeviceNode} >"${MyTempDir}/gdisk.txt"
		GUID=$(awk -F" " '/^Disk identifier/ {print $4}' <"${MyTempDir}/gdisk.txt")
		CountOfUnavailablePartitionTables=$(grep ': not present' "${MyTempDir}/gdisk.txt" | wc -l)
		if [ ${CountOfUnavailablePartitionTables} -eq 4 ]; then
			echo -e "\nSkipping ${DeviceNode} due to missing partition table. Use parted to create one."
			break
		else
			echo -e "\nExamining ${DeviceNode} with GUID ${GUID}\c"
		fi
		
		# get name hddtemp needs
		HddtempName="$(hddtemp --debug ${DeviceNode} | awk -F": " '/^Model: / {print $2}' | \
			cut -c-40 | sed 's/^[ \t]*//;s/[ \t]*$//')"
		# store smartctl output in temporary file
		smartctl -q noserial -s on -a ${DeviceNode} >"${MyTempDir}/smartctl.txt" 2>&1
		DeviceModel="$(awk -F": " '/^Device Model/ {print $2}' <"${MyTempDir}/smartctl.txt" | \
			sed 's/^[ \t]*//;s/[ \t]*$//')"
		if [ "X${DeviceModel}" = "X" ]; then
			# Reading S.M.A.R.T. failed, we try autodetect mode iterating through all
			# known smartctl modes (-d auto|sat|usbcypress|usbjmicron|usbprolific|usbsunplus)
			SMARTPrefix="$(CheckSMARTModes ${DeviceNode} 2>/dev/null)"
			if [ "X${SMARTPrefix}" = "X" ]; then
				# we can't query the disk. Time to give up
				echo -e "\nUnable to query the disk through S.M.A.R.T.\nPlease investigate manually using smartctl\n"
				break
			fi
		fi
		
		# user feedback
		if [ "X${SMARTPrefix}" = "X" ]; then
			echo -e " \n(accessible through S.M.A.R.T.)"
		else
			echo -e " \n(can be queried with \"-d ${SMARTPrefix}\" through S.M.A.R.T.)"
		fi

		# check for CRC and LCC attributes
		CRCAttribute=$(awk -F" " '/CRC_Error_Count/ {print $1}' <"${MyTempDir}/smartctl.txt")
		LCCAttribute=$(grep -i "load.cycle" "${MyTempDir}/smartctl.txt" | awk -F" " '{print $1}')
		
		# check whether /etc/hddtemp.db should be patched
		grep -q "${HddtempName}" /etc/hddtemp.db
		if [ $? -ne 0 ]; then
			# No entry into hddtemp database, we've a look whether there's a 'temperature'
			# attribute available (we take the 1st we find) and if that's the case we use this
			DiskTemp=$(awk -F" " '/Temperature/ {print $1}' <"${MyTempDir}/smartctl.txt" | head -n1)
			if [[ ${DiskTemp} -gt 0 ]]; then
				echo -e "\"${HddtempName}\" ${DiskTemp} C \"${DeviceModel}\"" >>/etc/hddtemp.db
				echo -e "\nAdded disk \"${DeviceModel}\"/\"${HddtempName}\" to /etc/hddtemp.db using S.M.A.R.T. attribute ${DiskTemp}\nbased on the following available thermal values:"
				grep "Temperature" "${MyTempDir}/smartctl.txt"
				# check hddtemp result
				HddtempResult=$(hddtemp -n ${DeviceNode} | grep -v 'not available' | awk -F" " '{print $1}')
				if [ "X${HddtempResult}" != "X${DeviceNode}:" ]; then
					# hddtemp isn't able to query the disk
					HddtempStatus="does not work. Please check with smartctl and adjust config accordingly"
					echo -e "\nhddtemp output: $(hddtemp ${DeviceNode})"
					echo -e "\nIt seems we can not rely on hddtemp to query this disk. Please try smartctl instead\n"
				else
					HddtempStatus="will work"
					echo -e "\nhddtemp output: ${HddtempResult})"
					echo -e "\nIn case this seems not to be correct please adjust /etc/hddtemp.db manually\n"
				fi
			else
				HddtempStatus="does not work. Please check with smartctl and adjust config accordingly"
			fi
		else
			HddtempStatus="will work"
		fi
		
		# check for firmware updates
		FirmwareUpdate="$(grep "^http" "${MyTempDir}/smartctl.txt")"
		
		# Check whether the disk (based on GUID) is already configured in our config file
		# /etc/armbianmonitor/disks.conf or not
		
		grep -q "^${GUID}:" /etc/armbianmonitor/disks.conf >/dev/null 2>/dev/null
		case $? in
			0)
				# already listed, we provide just infos:
				echo -e "Disk is already configured by the following monitoring config:\n$(grep "^${GUID}:" /etc/armbianmonitor/disks.conf)\n"
				;;
			*)
				# new disk, we recommend an entry for /etc/armbianmonitor/disks.conf
				echo -e "Disk not configured for monitoring. We were able to extract the following \ninformation:\n   GUID: ${GUID}"
				if [ "X${SMARTPrefix}" != "X" ]; then
					echo -e "   QueryMode: -d ${SMARTPrefix}"
				fi
				echo -e "   hddtemp: ${HddtempStatus}\n   CRC attribute: ${CRCAttribute}\n   LCC Attribute: ${LCCAttribute}"
				case ${HddtempStatus} in
					"will work")
						echo -e "If you want to monitor the disk please add to /etc/armbianmonitor/disks.conf:\n${GUID}:${DeviceModel}:${SMARTPrefix}::${CRCAttribute}:${LCCAttribute}"
						;;
					*)
						echo -e "Proposal for /etc/armbianmonitor/disks.conf:\n${GUID}:${DeviceModel}:${SMARTPrefix}:FIXME:${CRCAttribute}:${LCCAttribute}"
						echo -e "You have to figure out how to query the disk for its thermal sensor."
						echo -e "Please check the output of \"hddtemp --debug ${DeviceNode}\" and smartctl\n"
						;;
				esac		
				;;
		esac
		if [ "X${FirmwareUpdate}" != "X" ]; then
			echo -e "\nWARNING: A firmware update seems to be available:\n${FirmwareUpdate}\n"
		fi
	done
} # CheckDisks

CheckSMARTModes() {
	# This function tries to access USB disks through S.M.A.R.T. and returns the necessary
	# '-d' call as well as fills in ${MyTempDir}/smartctl.txt
	
	for i in auto sat usbcypress usbjmicron usbprolific usbsunplus ; do
		# user feedback
		# echo -n "." >/dev/tty
		# query disk using the specific protocol
		echo -n "" >"${MyTempDir}/smartctl.txt"
		smartctl -q noserial -s on -d ${i} -a ${1} >"${MyTempDir}/smartctl.txt" 2>/dev/null
		DeviceModel="$(awk -F": " '/^Device Model/ {print $2}' <"${MyTempDir}/smartctl.txt" | \
			sed 's/^[ \t]*//;s/[ \t]*$//')"
		if [ "X${DeviceModel}" != "X" ]; then
			echo ${i}
			break
		fi
	done
} # CheckSMARTModes

PreRequisits() {
	# Ensure that we're running as root since otherwise querying SATA/USB disks won't work
	if [ "$(id -u)" != "0" ]; then
		echo "This script must be run as root" >&2
		exit 1
	fi

	export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
	unset LANG
	DISTROCODE=$(lsb_release -s -c)
	
	# check whether gdisk/smartctl are available and up to date
	echo -e "Check whether necessary software is available\c"
	which gdisk >/dev/null 2>&1 || (echo -e " Installing gdisk\c" ; apt-get -f -qq -y install gdisk)
	which smartctl >/dev/null 2>&1 || (echo -e " Installing smartmontools\c" ; apt-get -f -qq -y install smartmontools)
	echo -e " [done]\nUpdating smartmontools' drivedb\c"
	/usr/sbin/update-smart-drivedb >/dev/null 2>&1
	if [ $? -ne 0 -a "X${DISTROCODE}" = "Xwheezy" ]; then
		sed -i "/^SRCEXPR/{s#=.*#='http://sourceforge.net/p/smartmontools/code/HEAD/tree/\$location/smartmontools/drivedb.h?format=raw'#}" /usr/sbin/update-smart-drivedb
		/usr/sbin/update-smart-drivedb
	fi
	echo -e " [done]"
	CreateTempDir
} # PreRequisits

CreateTempDir() {
	# create a safe temporary dir
	MyTempDir=$(mktemp -d /tmp/${0##*/}.XXXXXX)
	if [ ! -d "${MyTempDir}" ]; then
		MyTempDir=/tmp/${0##*/}.$RANDOM.$RANDOM.$RANDOM.$$
		(umask 066 && mkdir ${MyTempDir}) || (echo "Failed to create temp dir. Aborting" >&2 ; exit 1)
	fi
	chmod 711 "${MyTempDir}"
	trap "rm -rf \"${MyTempDir}\" ; exit 0" 0 1 2 3 15
	for file in smartctl.txt gdisk.txt ; do
		touch "${MyTempDir}/${file}"
		chmod 644 "${MyTempDir}/${file}"
	done
} #CreateTempFiles

InstallRPiMonitor() {
	# Installs rpimonitord based on the official instructions from
	# http://rpi-experiences.blogspot.fr/p/rpi-monitor-installation.html
	if [ "$(id -u)" != "0" ]; then
		echo "Installing RPi-Monitor requires root privileges, try sudo please. Exiting" >&2
		exit 1
	fi
	echo -e "Installing RPi-Monitor. This can take up to 5 minutes. Be patient please\c"
	apt-get -qq -y update
	apt-get -f -qq -y install rpimonitor
	/usr/share/rpimonitor/scripts/updatePackagesStatus.pl &
} # InstallRPiMonitor

PatchRPiMonitor_for_sun8i() {
	echo -e "\nNow patching RPi-Monitor to deal correctly with H3"
	cd / && echo "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
DRo0aNCgQYMGDRo0aNCg4SvCv8jHLasAoAAA" | base64 --decode | tar xzf -
	which systemctl >/dev/null 2>&1
	case $? in
		0)
			# Jessie
			systemctl enable rpimonitor-helper >/dev/null 2>&1
			systemctl start rpimonitor-helper >/dev/null 2>&1
			systemctl restart rpimonitor >/dev/null 2>&1
			;;
		*)
			# Wheezy|Trusty
			insserv rpimonitor-helper >/dev/null 2>&1 || update-rc.d rpimonitor-helper defaults 90 10 >/dev/null 2>&1
			cd /tmp && nohup /usr/local/sbin/rpimonitor-helper.sh & >/dev/null 2>&1
			/etc/init.d/rpimonitor stop >/dev/null 2>&1
			/etc/init.d/rpimonitor start >/dev/null 2>&1
			;;
	esac
} # PatchRPiMonitor_for_sun8i

CollectSupportInfo() {
	cat /var/log/armhwinfo.log
	[ -z $SUDO_USER ] || echo -e "\n### Group membership of $(groups $SUDO_USER)"
	echo -e "\n### Installed packages:\n\n$(dpkg -l | egrep "armbian| linux-")"
	KernelVersion=$(awk -F" " '{print $3}' < /proc/version)
	case ${KernelVersion} in
		3.*)
			[[ -e /boot/script.bin ]] && echo -e "\n### fex settings: $(ls -la /boot/script.bin)\n\n$(bin2fex /boot/script.bin 2>/dev/null)"
			;;
	esac
	echo -e "\n### dmesg now:\n\n$(dmesg | tail -n 250)"
	ls /tmp/armbianmonitor_checks_* >/dev/null 2>&1 || return
	for file in /tmp/armbianmonitor_checks_* ; do
		echo -e "\n### \c"
		ls "${file}" | cut -f1 -d.
		echo
		cat "${file}"
	done
} # CollectSupportInfo

CheckCard() {
	if [ "$(id -u)" = "0" ]; then
		echo "Checking disks is not permitted as root or through sudo. Exiting" >&2
		exit 1
	fi
	
	if [ ! -d "$1" ]; then
		echo "\"$1\" does not exist or is no directory. Exiting" >&2
		exit 1
	fi
	TargetDir="$1"

	# check requirements
	which f3write >/dev/null 2>&1 || MissingTools=" f3"
	which iozone >/dev/null 2>&1 || MissingTools="${MissingTools} iozone3"
	if [ "X${MissingTools}" != "X" ]; then
		echo "Some tools are missing, please do an \"sudo apt-get -f -y install${MissingTools}\" before and try again" >&2
		exit 1
	fi
	
	# check provided path
	Device="$(GetDevice "$1")"
	set ${Device}
	DeviceName=$1
	FileSystem=$2
	echo "${DeviceName}" | grep -q "mmcblk0" || echo -e "\n${BOLD}WARNING:${NC} It seems you're not testing the SD card but instead ${DeviceName} (${FileSystem})\n"
	
	TestDir="$(mktemp -d "${TargetDir}/cardtest.XXXXXX" || exit 1)"
	date "+%s" >"${TestDir}/.starttime" || exit 1
	trap "rm -rf \"${TestDir}\" ; exit 0" 0 1 2 3 15
	LogFile="$(mktemp /tmp/armbianmonitor_checks_${DeviceName##*/}_${FileSystem}.XXXXXX)"
	
	# start actual test, create a small file for some space reserve
	fallocate -l 32M "${TestDir}/empty.32m" 2>/dev/null || dd if=/dev/zero of="${TestDir}/empty.32m" bs=1M count=32 status=noxfer >/dev/null 2>&1
	ShowWarning=false
	# Start writing
	echo -e "Starting to fill ${DeviceName} with test patterns, please be patient this might take a very long time"
	f3write "${TestDir}" | tee "${LogFile}"
	touch "${TestDir}/.starttime" || ShowDeviceWarning
	rm "${TestDir}/empty.32m"
	# Start verify
	echo -e "\nNow verifying the written data:"
	echo "" >>"${LogFile}"
	f3read "${TestDir}" | tee -a "${LogFile}"
	touch "${TestDir}/.starttime" || ShowDeviceWarning
	rm "${TestDir}/"*.h2w
	echo -e "\nStarting iozone tests. Be patient, this can take a very long time to complete:"
	echo "" >>"${LogFile}"
	cd "${TestDir}"
	iozone -e -I -a -s 100M -r 4k -r 512k -r 16M -i 0 -i 1 -i 2 | tee -a "${LogFile}"
	touch "${TestDir}/.starttime" || ShowDeviceWarning
	echo -e "\n${BOLD}The results from testing ${DeviceName} (${FileSystem}):${NC}"
	egrep "Average|Data" "${LogFile}" | sort -r
	echo "                                            random    random"
	echo -e "reclen    write  rewrite    read    reread    read     write\c"
	awk -F"102400  " '/102400/ {print $2}' <"${LogFile}"

	# check health
	echo -e "\n${BOLD}Health summary: \c"
	egrep -q "Read-only|Input/output error" "${LogFile}" && (echo -e "${LRED}${BOLD}${DeviceName} failed${NC}" ; exit 0)
	grep -q "Data LOST: 0.00 Byte" "${LogFile}" && echo -e "${LGREEN}OK" || \
		(echo -e "${LRED}${BOLD}${DeviceName} failed. Replace it as soon as possible!" ; \
		grep -A3 "^Data LOST" "${LogFile}")

	# check performance
	RandomSpeed=$(awk -F" " '/102400       4/ {print $7"\t"$8}' <"${LogFile}")
	if [ "X${RandomSpeed}" != "X" ]; then
		# Only continue when we're able to read out iozone results
		set ${RandomSpeed}
		RandomReadSpead=$1
		RandomWriteSpead=$2
		ReadSpeed=$(awk -F" " '/Average reading speed/ {print $4"\t"$5}' <"${LogFile}")
		set ${ReadSpeed}
		if [ "X$2" = "XMB/s" ]; then
			RawReadSpead=$(echo "$1 * 1000" | bc -s | cut -f1 -d.)
		else
			RawReadSpead$(echo "$1" | cut -f1 -d.)
		fi
		echo -e "\n${NC}${BOLD}Performance summary:${NC}\nSequential reading speed:$(printf "%6s" $1) $2 \c"
		[ ${RawReadSpead} -le 2500 ] && Exclamation="${LRED}${BOLD}way " || Exclamation=""
		[ ${RawReadSpead} -le 5000 ] && Exclamation="${Exclamation}${BOLD}too "
		[ ${RawReadSpead} -le 7500 ] && echo -e "(${Exclamation}low${NC})\c"
		echo "${Exclamation}" | grep -q "too" && ShowWarning=true
		echo -e "\n 4K random reading speed:$(printf "%6s" ${RandomReadSpead}) KB/s \c"
		[ ${RandomReadSpead} -le 700 ] && Exclamation="${LRED}${BOLD}way " || Exclamation=""
		[ ${RandomReadSpead} -le 1400 ] && Exclamation="${Exclamation}${BOLD}too "
		[ ${RandomReadSpead} -le 2500 ] && echo -e "(${Exclamation}low${NC})\c"
		echo "${Exclamation}" | grep -q "too" && ShowWarning=true
		WriteSpeed=$(awk -F" " '/Average writing speed/ {print $4"\t"$5}' <"${LogFile}")
		set ${WriteSpeed}
		if [ "X$2" = "XMB/s" ]; then
			RawWriteSpeed=$(echo "$1 * 1000" | bc -s | cut -f1 -d.)
		else
			RawWriteSpeed=$(echo "$1" | cut -f1 -d.)
		fi
		echo -e "\nSequential writing speed:$(printf "%6s" $1) $2 \c"
		[ ${RawWriteSpeed} -le 2500 ] && Exclamation="${LRED}${BOLD}way " || Exclamation=""
		[ ${RawWriteSpeed} -le 4000 ] && Exclamation="${Exclamation}${BOLD}too "
		[ ${RawWriteSpeed} -le 6000 ] && echo -e "(${Exclamation}low${NC})\c"
		echo "${Exclamation}" | grep -q "too" && ShowWarning=true
		echo -e "\n 4K random writing speed:$(printf "%6s" ${RandomWriteSpead}) KB/s \c"
		[ ${RandomWriteSpead} -le 400 ] && Exclamation="${LRED}${BOLD}way " || Exclamation=""
		[ ${RandomWriteSpead} -le 750 ] && Exclamation="${Exclamation}${BOLD}too "
		[ ${RandomWriteSpead} -lt 1000 ] && echo -e "(${Exclamation}low${NC})\c"
		echo "${Exclamation}" | grep -q "too" && ShowWarning=true
		if [ "X${ShowWarning}" = "Xtrue" ]; then
			echo -e "\n\n${BOLD}The device you tested seems to perform too slow to be used with Armbian."
			echo -e "This applies especially to desktop images where slow storage is responsible"
			echo -e "for sluggish behaviour. If you want to have fun with your device do NOT use"
			echo -e "this media to put the OS image or the user homedirs on.${NC}\c"
		fi
		echo -e "\n\nTo interpret the results above correctly or search for better storage
alternatives please refer to http://oss.digirati.com.br/f3/ and also
http://www.jeffgeerling.com/blogs/jeff-geerling/raspberry-pi-microsd-card
and http://thewirecutter.com/reviews/best-microsd-card/"
	fi
} # CheckCard

ShowDeviceWarning() {
	echo -e "\n${LRED}${BOLD}Test stopped, read-only filesystem\n\n${NC}${LRED}$(dmesg | grep 'I/O error')"
	echo -e "\n${BOLD}Please be careful using this media since it seems it's already broken. Exiting test.\n${NC}"
	exit 0
} # ShowDeviceWarning

GetDevice() {
	TestPath=$(findmnt "$1" | awk -F" " '/\/dev\// {print $2"\t"$3}')
	if [[ -z ${TestPath} && -n "${1%/*}" ]]; then
		GetDevice "${1%/*}"
	elif [[ -z ${TestPath} && -z "${1%/*}" ]]; then
		findmnt / | awk -F" " '/\/dev\// {print $2"\t"$3}'
	else
		echo "${TestPath}"
	fi
} # GetDevice

Main "$@"
