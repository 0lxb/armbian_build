#!/bin/bash
#
# armbianmonitor
#
# This script serves different purposes based on how it is called:
#
# - toggle boot verbosity (works)
# - monitoring mode: continually print monitoring info (WiP)
# - uploading /var/log/armhwinfo.log to online pastebin service
#
# Without arguments called it should present a simple user
# interface that guides through:
#
# - installation of RPi-Monitor if not already installed by user
# - active basic or more verbose monitoring mode
# - provides monitoring parameters for connected disks
#
# The second part is WiP and all the user interaction part
# still completely missing.
#
# This script is used to configure armbianmonitor behaviour.
# It will ask the user whether to activate monitoring or not,
# whether to enable debug monitoring and also how to deal with
# connected disks. In fact it walks through the list of available
# disks, checks them, tries to patch hddtemp.db if necessary
# and provides a proposal for /etc/armbianmonitor/disks.conf
# when a new disk is found.
#
# In case monitoring should be activated the following file 
# will be created: /etc/armbianmonitor/start-monitoring. If 
# debug output has been chosen, then DEBUG will be written to 
# the file.
#
# The script will install smartmontools/gdisk if not already
# installed and patches smartmontools' update-smart-drivedb 
# script if necessary. For disks the 'device model' will be
# shown but internally we rely always on the GUID. This is the
# key for entry in /etc/armbianmonitor/disks.conf
#
# When the script exits and the user activated monitoring it
# recommends doing a restart since on the next reboot the
# setup-armbian-monitoring-environment script will configure 
# monitoring sources and decides based on the existence and 
# contents of /etc/armbianmonitor/start-monitoring whether 
# rpimonitord should be started or not.
#
# The format of /etc/armbianmonitor/disks.conf is as follows:
#
# ${GUID}:${Name}:${smartctl prefix}:${temp call}:${CRC}:${LCC}
#
# Two examples:
#
# A57BF307-7D82-4783-BD1D-B346CA8C195B:WD Green::199:193 # WD HDD on SATA
# F8D372DC-63DB-494B-B802-87DC47FAD4E1:Samsung EVO:sat::199: # SSD in USB enclosure
#
# - GUID is the GUID as determined by gdisk
# - 'Name': The name as it will later be shown in RPi-Monitor, defaults to 
#   the 'device model' read out through smartctl but can be changed to
#   be more significant (beware that this string must contain colons!)
# - "smartctl prefix" can be empty or should be the the necessary prefix for 
#   USB disks, eg. '-d sat' or '-d usbjmicron' and so on -- please have a 
#   look at https://www.smartmontools.org/wiki/Supported_USB-Devices
# - "temp call" when being omitted indicates that hddtemp should be used. 
#   Otherwise it should contain the complete command line ('DISK' will be 
#   dynamically replaced by the device node when the actual monitoring 
#   happens), for example:
#   /sbin/hdparm -C DISK | egrep -q "standby|sleeping" || /usr/sbin/smartctl -d sat -a DISK | awk -F" " '/Temperature_Cel/ {printf $10}'
# - 'CRC attribute': The decimal value of the S.M.A.R.T. attribute that
#   is used to store the count of checksum errors between disk and host 
#   controller (might be omitted if the drive doesn't support it)
# - 'LCC attribute': The decimal value of the S.M.A.R.T. attribute that 
#   should contain the load cycle counter value (might be omitted
#   if the drive doesn't support it)
#
# TODO:
#
# - develop main functionality ;) asking the user regarding monitoring
# - deal with 'SMART overall-health self-assessment test result:'
# - write documentation
#
############################################################################

Main() {
	export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

	# check if stdout is a terminal...
	if test -t 1; then
		# see if it supports colors...
		ncolors=$(tput colors)
		if test -n "$ncolors" && test $ncolors -ge 8; then
			BOLD="$(tput bold)"
			NC='\033[0m' # No Color
			LGREEN='\033[1;32m'
			LRED='\e[0;91m'
		fi
	fi
	
	[ $# -eq 0 ] && (DisplayUsage ; exit 0)
	
	ParseOptions "$@"

	exit 0
	PreRequisits
	
	# check whether user runs rpimonitord on his own or we activated it
	if [ -f /etc/armbianmonitor/start-monitoring ]; then
		# we should already provide monitoring, check whether DEBUG
		# is also set
		ArmbianMonitoring=TRUE
		read DebugMode </etc/armbianmonitor/start-monitoring 2>/dev/null
	fi
	
	# check whether rpimonitord is running and compare with ${ArmbianMonitoring}
	# In case the user chose to run rpimonitord on his own, we skip the config
	# part and only output disk info
	:
	
	# check available disk devices
	CheckDisks
} # Main

ParseOptions() {
	while getopts 'hHbBuUrRmMdDc:C:pP' c ; do
	case ${c} in
		H)
			# display full help test
			# export FullUsage=TRUE
			DisplayUsage
			exit 0
			;;
		h)
			# display short help
			DisplayUsage
			exit 0
			;;
		b|B)
			# toggle boot verbosity
			if [ -f /boot/.force-verbose ]; then
				rm /boot/.force-verbose
				echo -e "Verbose kernel messages have been disabled. Please reboot for changes to take effect."
			else
				date "+%s" >/boot/.force-verbose
				chmod 666 /boot/.force-verbose
				echo -e "Verbose kernel messages have been enabled. Please reboot for changes to take effect."
			fi
			exit 0
			;;
		m|M)
			# monitoring mode
			echo -e "Stop monitoring using [ctrl]-[c]"
			MonitorMode ${OPTARG}
			exit 0
			;;
		u|U)
			# Upload /var/log/armhwinfo.log to be of help in support forum.
			fping sprunge.us | grep -q alive || \
				(echo "Network/firewall problem detected. Please fix this or upload /var/log/armhwinfo.log manually." >&2 ; exit 1)
			which curl >/dev/null 2>&1 || apt-get -f -qq -y install curl
			echo -e "/var/log/armhwinfo.log has been uploaded to \c"
			# we obfuscate IPv4 addresses somehow but not too much, MAC addresses have to remain
			# in clear since otherwise the log becomes worthless due to randomly generated 
			# addresses here and there that might conflict
			CollectSupportInfo \
				| sed -E 's/([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3}\.)([0-9]{1,3})/XXX.XXX.\3\4/g' \
				| curl -F 'sprunge=<-' http://sprunge.us
			echo -e "Please post the URL in the Armbian forum where you've been asked for."
			exit 0
			;;
		r|R)
			# Installs RPi-Monitor and patches config on sun8i
			fping armbian.com | grep -q alive || \
				(echo "Network/firewall problem detected. Please fix this prior to installing RPi-Monitor." >&2 ; exit 1)
			InstallRPiMonitor
			case $(awk '/Hardware/ {print $3$4}' </proc/cpuinfo) in
				*sun8i*)
					PatchRPiMonitor_for_sun8i
					case $(uname -r) in
						3.4.*)
							sed -i 's|H3_Extended_Mainline.conf|H3_Extended.conf|' /etc/rpimonitor/template/OrangePi_H3.conf
							systemctl restart rpimonitor >/dev/null 2>&1
							;;
					esac
					;;
			esac
			echo -e "\nNow you're able to enjoy RPi-Monitor at http://$((ifconfig -a) | sed -n '/inet addr/s/.*addr.\([^ ]*\) .*/\1/p' | head -1):8888"
			exit 0
			;;
		p|P)
			# Installs cpuminer
			fping armbian.com | grep -q alive || \
				(echo "Network/firewall problem detected. Please fix this prior to installing cpuminer." >&2 ; exit 1)
			cd /usr/local/src/
			wget http://downloads.sourceforge.net/project/cpuminer/pooler-cpuminer-2.4.5.tar.gz
			tar xf pooler-cpuminer-2.4.5.tar.gz && rm pooler-cpuminer-2.4.5.tar.gz
			cd cpuminer-2.4.5/
			apt-get -f -qq -y install libcurl4-gnutls-dev
			./configure CFLAGS="-O3 -mfpu=neon"
			make && make install
			echo -e "\n\nNow you can use /usr/local/bin/minerd to do automated benchmarking.\nIn case you also installed RPi-Monitor you can do a"
			echo -e "\n    touch /root/.cpuminer\n\nto ensure minerd is running after reboot and results are recorded\nwith RPi-Monitor"
			exit 0
			;;
		d|D)
			fping sprunge.us | grep -q alive || \
				(echo "Network/firewall problem detected. Please fix this prior to installing RPi-Monitor." >&2 ; exit 1)
			DebugOutput="$(mktemp /tmp/${0##*/}.XXXXXX)"
			trap "rm \"${DebugOutput}\" ; exit 0" 0 1 2 3 15
			set -x
			exec 2>"${DebugOutput}"
			PreRequisits >/dev/null 2>&1
			CheckDisks
			which curl >/dev/null 2>&1 || apt-get -f -qq -y install curl
			echo -e "\nDebug output has been collected at the following URL: \c"
			(cat "${DebugOutput}"; echo -e "\n\n\ngdisk.txt contents:\n" ; cat "${MyTempDir}/gdisk.txt" ;\
				echo -e "\n\n\nsmartctl.txt contents:\n" ; cat "${MyTempDir}/smartctl.txt") \
				| curl -F 'sprunge=<-' http://sprunge.us
			echo -e "Please post the URL in the Armbian forum where you've been asked for."
			exit 0			
			;;
		c|C)
			# check card mode
			CheckCard "${OPTARG}"
			exit 0
			;;
	esac
	done
} # ParseOptions

DisplayUsage() {
	echo -e "Usage: ${BOLD}${0##*/} [-h] [-b] [-c \$path] [-d] [-m] [-p] [-r] [-u]${NC}\n"
	echo -e "############################################################################"
	if [ ${FullUsage} ]; then
		echo -e "\nDetailed Description:"
		grep "^#" "$0" | grep -v "^#\!/bin/bash" | sed 's/^#//'
	fi
	echo -e "\n Use ${BOLD}armbianmonitor${NC} for the following tasks:\n"
	echo -e " armbianmonitor ${BOLD}-b${NC} switches between verbose and normal boot"
	echo -e " armbianmonitor ${BOLD}-c /path/to/test${NC} performs disk health/performance tests"
	echo -e " armbianmonitor ${BOLD}-d${NC} tries to upload debug disk info to improve armbianmonitor"
	echo -e " armbianmonitor ${BOLD}-m${NC} provides simple CLI monitoring"
	echo -e " armbianmonitor ${BOLD}-p${NC} installs cpuminder for performance measurements"
	echo -e " armbianmonitor ${BOLD}-r${NC} tries to install RPi-Monitor"
	echo -e " armbianmonitor ${BOLD}-u${NC} tries to upload armhwinfo.log for support purposes\n"
	echo -e "############################################################################\n"
} # DisplayUsage

MonitorMode() {
	# $1 is the time in seconds to pause between two prints, defaults to 5 seconds
	# This functions prints out endlessly:
	# - time/date
	# - average 1m load
	# - detailed CPU statistics
	# - Soc temperature if available
	# - PMIC temperature if available
	# TODO: Format output nicely
	LastUserStat=0
	LastNiceStat=0
	LastSystemStat=0
	LastIdleStat=0
	LastIOWaitStat=0
	LastIrqStat=0
	LastSoftIrqStat=0
	LastCpuStatCheck=0

	Sensors="/etc/armbianmonitor/datasources/"
	echo -e "Time        CPU    load %cpu %sys %usr %nice %io %irq\c"
	[ -f "${Sensors}/soctemp" ] && echo -e "   CPU\c"
	[ -f "${Sensors}/pmictemp" ] && echo -e "   PMIC\c"
	while true ; do
		LoadAvg=$(cut -f1 -d" " </proc/loadavg)
		CpuFreq=$(awk '{printf ("%0.0f",$1/1000); }' </sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq)
		echo -e "\n$(date "+%H:%M:%S"): $(printf "%4s" ${CpuFreq})MHz $(printf "%5s" ${LoadAvg}) $(ProcessStats)\c"
		if [ -f "${Sensors}/soctemp" ]; then
			read SocTemp <"${Sensors}/soctemp"
			if [ ${SocTemp} -ge 1000 ]; then
				SocTemp=$(awk '{printf ("%0.1f",$1/1000); }' <"${Sensors}/soctemp")
			fi
			echo -e " $(printf "%4s" ${SocTemp})°C\c"
		fi
		[ -f "${Sensors}/pmictemp" ] && \
			(PMICTemp=$(awk '{printf ("%0.1f",$1/1000); }' <"${Sensors}/pmictemp") ; echo -e " $(printf "%4s" ${PMICTemp})°C\c")
		sleep ${1:-5}
	done
} # MonitorMode

ProcessStats() {
	if [ -f /tmp/cpustat ]; then
		# RPi-Monitor/Armbianmonitor already running and providing processed values
		set $(awk -F" " '{print $1"\t"$2"\t"$3"\t"$4"\t"$5"\t"$6}' </tmp/cpustat)
		CPULoad=$1
		SystemLoad=$2
		UserLoad=$3
		NiceLoad=$4
		IOWaitLoad=$5
		IrqCombinedLoad=$6		
	else
		set $(awk -F" " '/^cpu / {print $2"\t"$3"\t"$4"\t"$5"\t"$6"\t"$7"\t"$8}' </proc/stat)
		UserStat=$1
		NiceStat=$2
		SystemStat=$3
		IdleStat=$4
		IOWaitStat=$5
		IrqStat=$6
		SoftIrqStat=$7
		
		UserDiff=$(( ${UserStat} - ${LastUserStat} ))
		NiceDiff=$(( ${NiceStat} - ${LastNiceStat} ))
		SystemDiff=$(( ${SystemStat} - ${LastSystemStat} ))
		IdleDiff=$(( ${IdleStat} - ${LastIdleStat} ))
		IOWaitDiff=$(( ${IOWaitStat} - ${LastIOWaitStat} ))
		IrqDiff=$(( ${IrqStat} - ${LastIrqStat} ))
		SoftIrqDiff=$(( ${SoftIrqStat} - ${LastSoftIrqStat} ))
		
		Total=$(( ${UserDiff} + ${NiceDiff} + ${SystemDiff} + ${IdleDiff} + ${IOWaitDiff} + ${IrqDiff} + ${SoftIrqDiff} ))
		CPULoad=$(( ( ${Total} - ${IdleDiff} ) * 100 / ${Total} ))
		UserLoad=$(( ${UserDiff} *100 / ${Total} ))
		SystemLoad=$(( ${SystemDiff} *100 / ${Total} ))
		NiceLoad=$(( ${NiceDiff} *100 / ${Total} ))
		IOWaitLoad=$(( ${IOWaitDiff} *100 / ${Total} ))
		IrqCombinedLoad=$(( ( ${IrqDiff} + ${SoftIrqDiff} ) *100 / ${Total} ))

		LastUserStat=${UserStat}
		LastNiceStat=${NiceStat}
		LastSystemStat=${SystemStat}
		LastIdleStat=${IdleStat}
		LastIOWaitStat=${IOWaitStat}
		LastIrqStat=${IrqStat}
		LastSoftIrqStat=${SoftIrqStat}
	fi
	echo -e "$(printf "%3s" ${CPULoad})%$(printf "%4s" ${SystemLoad})%$(printf "%4s" ${UserLoad})%$(printf "%4s" ${NiceLoad})%$(printf "%4s" ${IOWaitLoad})%$(printf "%4s" ${IrqCombinedLoad})%"

} # ProcessStats

CheckDisks() {
	# This function walks through all block devices whose name starts with sd* and
	# then gets the name hddtemp expects, the model name from smartctl, looks whether
	# the drive only lists one temperature value and patches hddtemp.db if necessary
	# and also tries to get CRC and LCC S.M.A.R.T. attributes to provide the user
	# with the necessary config file contents for /etc/armbianmonitor/disks.conf:
	
	ls /sys/block/sd* >/dev/null 2>&1 || exit 0
	
	for i in /sys/block/sd* ; do
		DeviceNode=/dev/${i##*/}
		# get GUID/UUID for disk and check whether a partition table is existent. If
		# not GUID will always be random
		gdisk -l ${DeviceNode} >"${MyTempDir}/gdisk.txt"
		GUID=$(awk -F" " '/^Disk identifier/ {print $4}' <"${MyTempDir}/gdisk.txt")
		CountOfUnavailablePartitionTables=$(grep ': not present' "${MyTempDir}/gdisk.txt" | wc -l)
		if [ ${CountOfUnavailablePartitionTables} -eq 4 ]; then
			echo -e "\nSkipping ${DeviceNode} due to missing partition table. Use parted to create one."
			break
		else
			echo -e "\nExamining ${DeviceNode} with GUID ${GUID}\c"
		fi
		
		# get name hddtemp needs
		HddtempName="$(hddtemp --debug ${DeviceNode} | awk -F": " '/^Model: / {print $2}' | \
			cut -c-40 | sed 's/^[ \t]*//;s/[ \t]*$//')"
		# store smartctl output in temporary file
		smartctl -q noserial -s on -a ${DeviceNode} >"${MyTempDir}/smartctl.txt" 2>&1
		DeviceModel="$(awk -F": " '/^Device Model/ {print $2}' <"${MyTempDir}/smartctl.txt" | \
			sed 's/^[ \t]*//;s/[ \t]*$//')"
		if [ "X${DeviceModel}" = "X" ]; then
			# Reading S.M.A.R.T. failed, we try autodetect mode iterating through all
			# known smartctl modes (-d auto|sat|usbcypress|usbjmicron|usbprolific|usbsunplus)
			SMARTPrefix="$(CheckSMARTModes ${DeviceNode} 2>/dev/null)"
			if [ "X${SMARTPrefix}" = "X" ]; then
				# we can't query the disk. Time to give up
				echo -e "\nUnable to query the disk through S.M.A.R.T.\nPlease investigate manually using smartctl\n"
				break
			fi
		fi
		
		# user feedback
		if [ "X${SMARTPrefix}" = "X" ]; then
			echo -e " \n(accessible through S.M.A.R.T.)"
		else
			echo -e " \n(can be queried with \"-d ${SMARTPrefix}\" through S.M.A.R.T.)"
		fi

		# check for CRC and LCC attributes
		CRCAttribute=$(awk -F" " '/CRC_Error_Count/ {print $1}' <"${MyTempDir}/smartctl.txt")
		LCCAttribute=$(grep -i "load.cycle" "${MyTempDir}/smartctl.txt" | awk -F" " '{print $1}')
		
		# check whether /etc/hddtemp.db should be patched
		grep -q "${HddtempName}" /etc/hddtemp.db
		if [ $? -ne 0 ]; then
			# No entry into hddtemp database, we've a look whether there's a 'temperature'
			# attribute available (we take the 1st we find) and if that's the case we use this
			DiskTemp=$(awk -F" " '/Temperature/ {print $1}' <"${MyTempDir}/smartctl.txt" | head -n1)
			if [[ ${DiskTemp} -gt 0 ]]; then
				echo -e "\"${HddtempName}\" ${DiskTemp} C \"${DeviceModel}\"" >>/etc/hddtemp.db
				echo -e "\nAdded disk \"${DeviceModel}\"/\"${HddtempName}\" to /etc/hddtemp.db using S.M.A.R.T. attribute ${DiskTemp}\nbased on the following available thermal values:"
				grep "Temperature" "${MyTempDir}/smartctl.txt"
				# check hddtemp result
				HddtempResult=$(hddtemp -n ${DeviceNode} | grep -v 'not available' | awk -F" " '{print $1}')
				if [ "X${HddtempResult}" != "X${DeviceNode}:" ]; then
					# hddtemp isn't able to query the disk
					HddtempStatus="does not work. Please check with smartctl and adjust config accordingly"
					echo -e "\nhddtemp output: $(hddtemp ${DeviceNode})"
					echo -e "\nIt seems we can not rely on hddtemp to query this disk. Please try smartctl instead\n"
				else
					HddtempStatus="will work"
					echo -e "\nhddtemp output: ${HddtempResult})"
					echo -e "\nIn case this seems not to be correct please adjust /etc/hddtemp.db manually\n"
				fi
			else
				HddtempStatus="does not work. Please check with smartctl and adjust config accordingly"
			fi
		else
			HddtempStatus="will work"
		fi
		
		# check for firmware updates
		FirmwareUpdate="$(grep "^http" "${MyTempDir}/smartctl.txt")"
		
		# Check whether the disk (based on GUID) is already configured in our config file
		# /etc/armbianmonitor/disks.conf or not
		
		grep -q "^${GUID}:" /etc/armbianmonitor/disks.conf >/dev/null 2>/dev/null
		case $? in
			0)
				# already listed, we provide just infos:
				echo -e "Disk is already configured by the following monitoring config:\n$(grep "^${GUID}:" /etc/armbianmonitor/disks.conf)\n"
				;;
			*)
				# new disk, we recommend an entry for /etc/armbianmonitor/disks.conf
				echo -e "Disk not configured for monitoring. We were able to extract the following \ninformation:\n   GUID: ${GUID}"
				if [ "X${SMARTPrefix}" != "X" ]; then
					echo -e "   QueryMode: -d ${SMARTPrefix}"
				fi
				echo -e "   hddtemp: ${HddtempStatus}\n   CRC attribute: ${CRCAttribute}\n   LCC Attribute: ${LCCAttribute}"
				case ${HddtempStatus} in
					"will work")
						echo -e "If you want to monitor the disk please add to /etc/armbianmonitor/disks.conf:\n${GUID}:${DeviceModel}:${SMARTPrefix}::${CRCAttribute}:${LCCAttribute}"
						;;
					*)
						echo -e "Proposal for /etc/armbianmonitor/disks.conf:\n${GUID}:${DeviceModel}:${SMARTPrefix}:FIXME:${CRCAttribute}:${LCCAttribute}"
						echo -e "You have to figure out how to query the disk for its thermal sensor."
						echo -e "Please check the output of \"hddtemp --debug ${DeviceNode}\" and smartctl\n"
						;;
				esac		
				;;
		esac
		if [ "X${FirmwareUpdate}" != "X" ]; then
			echo -e "\nWARNING: A firmware update seems to be available:\n${FirmwareUpdate}\n"
		fi
	done
} # CheckDisks

CheckSMARTModes() {
	# This function tries to access USB disks through S.M.A.R.T. and returns the necessary
	# '-d' call as well as fills in ${MyTempDir}/smartctl.txt
	
	for i in auto sat usbcypress usbjmicron usbprolific usbsunplus ; do
		# user feedback
		# echo -n "." >/dev/tty
		# query disk using the specific protocol
		echo -n "" >"${MyTempDir}/smartctl.txt"
		smartctl -q noserial -s on -d ${i} -a ${1} >"${MyTempDir}/smartctl.txt" 2>/dev/null
		DeviceModel="$(awk -F": " '/^Device Model/ {print $2}' <"${MyTempDir}/smartctl.txt" | \
			sed 's/^[ \t]*//;s/[ \t]*$//')"
		if [ "X${DeviceModel}" != "X" ]; then
			echo ${i}
			break
		fi
	done
} # CheckSMARTModes

PreRequisits() {
	# Ensure that we're running as root since otherwise querying SATA/USB disks won't work
	if [ "$(id -u)" != "0" ]; then
		echo "This script must be run as root" >&2
		exit 1
	fi

	export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
	unset LANG
	DISTROCODE=$(lsb_release -s -c)
	
	# check whether gdisk/smartctl are available and up to date
	echo -e "Check whether necessary software is available\c"
	which gdisk >/dev/null 2>&1 || (echo -e " Installing gdisk\c" ; apt-get -f -qq -y install gdisk)
	which smartctl >/dev/null 2>&1 || (echo -e " Installing smartmontools\c" ; apt-get -f -qq -y install smartmontools)
	echo -e " [done]\nUpdating smartmontools' drivedb\c"
	/usr/sbin/update-smart-drivedb >/dev/null 2>&1
	if [ $? -ne 0 -a "X${DISTROCODE}" = "Xwheezy" ]; then
		sed -i "/^SRCEXPR/{s#=.*#='http://sourceforge.net/p/smartmontools/code/HEAD/tree/\$location/smartmontools/drivedb.h?format=raw'#}" /usr/sbin/update-smart-drivedb
		/usr/sbin/update-smart-drivedb
	fi
	echo -e " [done]"
	CreateTempDir
} # PreRequisits

CreateTempDir() {
	# create a safe temporary dir
	MyTempDir=$(mktemp -d /tmp/${0##*/}.XXXXXX)
	if [ ! -d "${MyTempDir}" ]; then
		MyTempDir=/tmp/${0##*/}.$RANDOM.$RANDOM.$RANDOM.$$
		(umask 066 && mkdir ${MyTempDir}) || (echo "Failed to create temp dir. Aborting" >&2 ; exit 1)
	fi
	chmod 711 "${MyTempDir}"
	trap "rm -rf \"${MyTempDir}\" ; exit 0" 0 1 2 3 15
	for file in smartctl.txt gdisk.txt ; do
		touch "${MyTempDir}/${file}"
		chmod 644 "${MyTempDir}/${file}"
	done
} #CreateTempFiles

InstallRPiMonitor() {
	# Installs rpimonitord based on the official instructions from
	# http://rpi-experiences.blogspot.fr/p/rpi-monitor-installation.html
	if [ "$(id -u)" != "0" ]; then
		echo "Installing RPi-Monitor requires root privileges, try sudo please. Exiting" >&2
		exit 1
	fi
	echo -e "Installing RPi-Monitor. This can take up to 5 minutes. Be patient please\c"
	apt-get -qq -y update
	apt-get -f -qq -y install rpimonitor
	/usr/share/rpimonitor/scripts/updatePackagesStatus.pl &
} # InstallRPiMonitor

PatchRPiMonitor_for_sun8i() {
	echo -e "\nNow patching RPi-Monitor to deal correctly with H3"
	cd / && echo "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
DRo0aNCgQYMGDRo0aNDwBeEf3K1XmgCgAAA=" | base64 --decode | tar xzf -
	which systemctl >/dev/null 2>&1
	case $? in
		0)
			# Jessie
			systemctl enable rpimonitor-helper >/dev/null 2>&1
			systemctl start rpimonitor-helper >/dev/null 2>&1
			systemctl restart rpimonitor >/dev/null 2>&1
			;;
		*)
			# Wheezy|Trusty
			insserv rpimonitor-helper >/dev/null 2>&1 || update-rc.d rpimonitor-helper defaults 90 10 >/dev/null 2>&1
			cd /tmp && nohup /usr/local/sbin/rpimonitor-helper.sh & >/dev/null 2>&1
			/etc/init.d/rpimonitor stop >/dev/null 2>&1
			/etc/init.d/rpimonitor start >/dev/null 2>&1
			;;
	esac
} # PatchRPiMonitor_for_sun8i

CollectSupportInfo() {
	cat /var/log/armhwinfo.log
	[ -z $SUDO_USER ] || echo -e "\n### Group membership of $(groups $SUDO_USER)"
	echo -e "\n### Installed packages:\n\n$(dpkg -l | egrep "armbian| linux-")"
	KernelVersion=$(awk -F" " '{print $3}' < /proc/version)
	case ${KernelVersion} in
		3.*)
			[[ -e /boot/script.bin ]] && echo -e "\n### fex settings: $(ls -la /boot/script.bin)\n\n$(bin2fex /boot/script.bin 2>/dev/null)"
			;;
	esac
	echo -e "\n### dmesg now:\n\n$(dmesg | tail -n 250)"
	ls /tmp/armbianmonitor_checks_* >/dev/null 2>&1 || return
	for file in /tmp/armbianmonitor_checks_* ; do
		echo -e "\n### \c"
		ls "${file}" | cut -f1 -d.
		echo
		cat "${file}"
	done
} # CollectSupportInfo

CheckCard() {
	if [ "$(id -u)" = "0" ]; then
		echo "Checking disks is not permitted as root or through sudo. Exiting" >&2
		exit 1
	fi
	
	if [ ! -d "$1" ]; then
		echo "\"$1\" does not exist or is no directory. Exiting" >&2
		exit 1
	fi
	TargetDir="$1"

	# check requirements
	which f3write >/dev/null 2>&1 || MissingTools=" f3"
	which iozone >/dev/null 2>&1 || MissingTools="${MissingTools} iozone3"
	if [ "X${MissingTools}" != "X" ]; then
		echo "Some tools are missing, please do an \"sudo apt-get -f -y install${MissingTools}\" before and try again" >&2
		exit 1
	fi
	
	# check provided path
	Device="$(GetDevice "$1")"
	set ${Device}
	DeviceName=$1
	FileSystem=$2
	echo "${DeviceName}" | grep -q "mmcblk0" || echo -e "\n${BOLD}WARNING:${NC} It seems you're not testing the SD card but instead ${DeviceName} (${FileSystem})\n"
	
	TestDir="$(mktemp -d "${TargetDir}/cardtest.XXXXXX" || exit 1)"
	date "+%s" >"${TestDir}/.starttime" || exit 1
	trap "rm -rf \"${TestDir}\" ; exit 0" 0 1 2 3 15
	LogFile="$(mktemp /tmp/armbianmonitor_checks_${DeviceName##*/}_${FileSystem}.XXXXXX)"
	
	# start actual test, create a small file for some space reserve
	fallocate -l 32M "${TestDir}/empty.32m" 2>/dev/null || dd if=/dev/zero of="${TestDir}/empty.32m" bs=1M count=32 status=noxfer >/dev/null 2>&1
	ShowWarning=false
	# Start writing
	echo -e "Starting to fill ${DeviceName} with test patterns, please be patient this might take a very long time"
	f3write "${TestDir}" | tee "${LogFile}"
	touch "${TestDir}/.starttime" || ShowDeviceWarning
	rm "${TestDir}/empty.32m"
	# Start verify
	echo -e "\nNow verifying the written data:"
	echo "" >>"${LogFile}"
	f3read "${TestDir}" | tee -a "${LogFile}"
	touch "${TestDir}/.starttime" || ShowDeviceWarning
	rm "${TestDir}/"*.h2w
	echo -e "\nStarting iozone tests. Be patient, this can take a very long time to complete:"
	echo "" >>"${LogFile}"
	cd "${TestDir}"
	iozone -e -I -a -s 100M -r 4k -r 512k -r 16M -i 0 -i 1 -i 2 | tee -a "${LogFile}"
	touch "${TestDir}/.starttime" || ShowDeviceWarning
	echo -e "\n${BOLD}The results from testing ${DeviceName} (${FileSystem}):${NC}"
	egrep "Average|Data" "${LogFile}" | sort -r
	echo "                                            random    random"
	echo -e "reclen    write  rewrite    read    reread    read     write\c"
	awk -F"102400  " '/102400/ {print $2}' <"${LogFile}"

	# check health
	echo -e "\n${BOLD}Health summary: \c"
	egrep -q "Read-only|Input/output error" "${LogFile}" && (echo -e "${LRED}${BOLD}${DeviceName} failed${NC}" ; exit 0)
	grep -q "Data LOST: 0.00 Byte" "${LogFile}" && echo -e "${LGREEN}OK" || \
		(echo -e "${LRED}${BOLD}${DeviceName} failed. Replace it as soon as possible!" ; \
		grep -A3 "^Data LOST" "${LogFile}")

	# check performance
	RandomSpeed=$(awk -F" " '/102400       4/ {print $7"\t"$8}' <"${LogFile}")
	if [ "X${RandomSpeed}" != "X" ]; then
		# Only continue when we're able to read out iozone results
		set ${RandomSpeed}
		RandomReadSpead=$1
		RandomWriteSpead=$2
		ReadSpeed=$(awk -F" " '/Average reading speed/ {print $4"\t"$5}' <"${LogFile}")
		set ${ReadSpeed}
		if [ "X$2" = "XMB/s" ]; then
			RawReadSpead=$(echo "$1 * 1000" | bc -s | cut -f1 -d.)
		else
			RawReadSpead$(echo "$1" | cut -f1 -d.)
		fi
		echo -e "\n${NC}${BOLD}Performance summary:${NC}\nSequential reading speed:$(printf "%6s" $1) $2 \c"
		[ ${RawReadSpead} -le 2500 ] && Exclamation="${LRED}${BOLD}way " || Exclamation=""
		[ ${RawReadSpead} -le 5000 ] && Exclamation="${Exclamation}${BOLD}too "
		[ ${RawReadSpead} -le 7500 ] && echo -e "(${Exclamation}low${NC})\c"
		echo "${Exclamation}" | grep -q "too" && ShowWarning=true
		echo -e "\n 4K random reading speed:$(printf "%6s" ${RandomReadSpead}) KB/s \c"
		[ ${RandomReadSpead} -le 700 ] && Exclamation="${LRED}${BOLD}way " || Exclamation=""
		[ ${RandomReadSpead} -le 1400 ] && Exclamation="${Exclamation}${BOLD}too "
		[ ${RandomReadSpead} -le 2500 ] && echo -e "(${Exclamation}low${NC})\c"
		echo "${Exclamation}" | grep -q "too" && ShowWarning=true
		WriteSpeed=$(awk -F" " '/Average writing speed/ {print $4"\t"$5}' <"${LogFile}")
		set ${WriteSpeed}
		if [ "X$2" = "XMB/s" ]; then
			RawWriteSpeed=$(echo "$1 * 1000" | bc -s | cut -f1 -d.)
		else
			RawWriteSpeed=$(echo "$1" | cut -f1 -d.)
		fi
		echo -e "\nSequential writing speed:$(printf "%6s" $1) $2 \c"
		[ ${RawWriteSpeed} -le 2500 ] && Exclamation="${LRED}${BOLD}way " || Exclamation=""
		[ ${RawWriteSpeed} -le 4000 ] && Exclamation="${Exclamation}${BOLD}too "
		[ ${RawWriteSpeed} -le 6000 ] && echo -e "(${Exclamation}low${NC})\c"
		echo "${Exclamation}" | grep -q "too" && ShowWarning=true
		echo -e "\n 4K random writing speed:$(printf "%6s" ${RandomWriteSpead}) KB/s \c"
		[ ${RandomWriteSpead} -le 400 ] && Exclamation="${LRED}${BOLD}way " || Exclamation=""
		[ ${RandomWriteSpead} -le 750 ] && Exclamation="${Exclamation}${BOLD}too "
		[ ${RandomWriteSpead} -lt 1000 ] && echo -e "(${Exclamation}low${NC})\c"
		echo "${Exclamation}" | grep -q "too" && ShowWarning=true
		if [ "X${ShowWarning}" = "Xtrue" ]; then
			echo -e "\n\n${BOLD}The device you tested seems to perform too slow to be used with Armbian."
			echo -e "This applies especially to desktop images where slow storage is responsible"
			echo -e "for sluggish behaviour. If you want to have fun with your device do NOT use"
			echo -e "this media to put the OS image or the user homedirs on.${NC}\c"
		fi
		echo -e "\n\nTo interpret the results above correctly or search for better storage
alternatives please refer to http://oss.digirati.com.br/f3/ and also
http://www.jeffgeerling.com/blogs/jeff-geerling/raspberry-pi-microsd-card
and http://thewirecutter.com/reviews/best-microsd-card/"
	fi
} # CheckCard

ShowDeviceWarning() {
	echo -e "\n${LRED}${BOLD}Test stopped, read-only filesystem\n\n${NC}${LRED}$(dmesg | grep 'I/O error')"
	echo -e "\n${BOLD}Please be careful using this media since it seems it's already broken. Exiting test.\n${NC}"
	exit 0
} # ShowDeviceWarning

GetDevice() {
	TestPath=$(findmnt "$1" | awk -F" " '/\/dev\// {print $2"\t"$3}')
	if [[ -z ${TestPath} && -n "${1%/*}" ]]; then
		GetDevice "${1%/*}"
	elif [[ -z ${TestPath} && -z "${1%/*}" ]]; then
		findmnt / | awk -F" " '/\/dev\// {print $2"\t"$3}'
	else
		echo "${TestPath}"
	fi
} # GetDevice

Main "$@"
