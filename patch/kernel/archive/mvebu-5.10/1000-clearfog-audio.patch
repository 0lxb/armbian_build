From 2fc25fbe1546ee1d33b224b59b0d5db2900a903d Mon Sep 17 00:00:00 2001
From: Heisath <jannis@imserv.org>
Date: Sun, 14 Mar 2021 18:54:13 +0100
Subject: [PATCH] clearfog-sound

Signed-off-by: Heisath <jannis@imserv.org>
---
 .../bindings/sound/armada-370db-audio.txt     |  12 +-
 .../devicetree/bindings/sound/mvebu-audio.txt |  12 ++
 arch/arm/boot/dts/armada-388-clearfog.dtsi    |  24 ++++
 arch/arm/boot/dts/armada-38x.dtsi             |  44 ++++++
 sound/soc/codecs/uda1334.c                    |   2 +
 sound/soc/kirkwood/armada-370-db.c            |  23 +--
 sound/soc/kirkwood/kirkwood-i2s.c             | 135 +++++++++++++++++-
 sound/soc/kirkwood/kirkwood.h                 |   2 +
 8 files changed, 238 insertions(+), 16 deletions(-)

diff --git a/Documentation/devicetree/bindings/sound/armada-370db-audio.txt b/Documentation/devicetree/bindings/sound/armada-370db-audio.txt
index 953c092db..43ae98a15 100644
--- a/Documentation/devicetree/bindings/sound/armada-370db-audio.txt
+++ b/Documentation/devicetree/bindings/sound/armada-370db-audio.txt
@@ -1,19 +1,19 @@
-Device Tree bindings for the Armada 370 DB audio
-================================================
+Device Tree bindings for the Armada 370/385 DB audio
+====================================================
 
 These Device Tree bindings are used to describe the audio complex
-found on the Armada 370 DB platform.
+found on the Armada 370 DB and Armada 385 DB platforms.
 
 Mandatory properties:
 
- * compatible: must be "marvell,a370db-audio"
+ * compatible: must be "marvell,a370db-audio" or "marvell,a385db-audio"
 
  * marvell,audio-controller: a phandle that points to the audio
-   controller of the Armada 370 SoC.
+   controller of the Armada 370/385 SoC.
 
  * marvell,audio-codec: a set of three phandles that points to:
 
-    1/ the analog audio codec connected to the Armada 370 SoC
+    1/ the analog audio codec connected to the Armada 370/A385 SoC
     2/ the S/PDIF transceiver
     3/ the S/PDIF receiver
 
diff --git a/Documentation/devicetree/bindings/sound/mvebu-audio.txt b/Documentation/devicetree/bindings/sound/mvebu-audio.txt
index cb8c07c81..90f52baf4 100644
--- a/Documentation/devicetree/bindings/sound/mvebu-audio.txt
+++ b/Documentation/devicetree/bindings/sound/mvebu-audio.txt
@@ -6,9 +6,14 @@ Required properties:
   "marvell,kirkwood-audio" for Kirkwood platforms
   "marvell,dove-audio" for Dove platforms
   "marvell,armada370-audio" for Armada 370 platforms
+  "marvell,armada-380-audio" for Armada 38x platforms
 
 - reg: physical base address of the controller and length of memory mapped
   region.
+  With "marvell,armada-380-audio" two other regions are required:
+  first of those is dedicated for Audio PLL Configuration rgisters
+  and the second one - for register where one of exceptive I/O types
+  (I2S or S/PDIF) is set.
 
 - interrupts:
   with "marvell,kirkwood-audio", the audio interrupt
@@ -23,6 +28,13 @@ Required properties:
 	"internal" for the internal clock
 	"extclk" for the external clock
 
+Optional properties:
+
+- spdif-mode:
+  Enable S/PDIF mode on Armada 38x SoC. Using this property
+  disables standard I2S I/O. Valid only with "marvell,armada-380-audio"
+  compatible string.
+
 Example:
 
 i2s1: audio-controller@b4000 {
diff --git a/arch/arm/boot/dts/armada-388-clearfog.dtsi b/arch/arm/boot/dts/armada-388-clearfog.dtsi
index a0aa1d188..3011d775d 100644
--- a/arch/arm/boot/dts/armada-388-clearfog.dtsi
+++ b/arch/arm/boot/dts/armada-388-clearfog.dtsi
@@ -61,6 +61,18 @@ usb3@f8000 {
 				/* CON7 */
 				status = "okay";
 			};
+			
+			tdm@b0000 {
+				pinctrl-0 = <&tdm_pins>;
+				pinctrl-names = "default";
+				pclk-freq-mhz = <8>;
+			};
+
+			audio-controller@e8000 {
+				pinctrl-0 = <&i2s_pins>;
+				pinctrl-names = "default";
+			};
+			
 		};
 
 		pcie {
@@ -86,6 +98,17 @@ sfp: sfp {
 		tx-fault-gpio = <&expander0 13 GPIO_ACTIVE_HIGH>;
 		maximum-power-milliwatt = <2000>;
 	};
+	
+    sound {
+            compatible = "marvell,a385db-audio";
+            marvell,audio-codec = <&uda1334 &spdif_out &spdif_in>;
+    };
+    
+    uda1334: audio-codec {
+	    compatible = "nxp,uda1334";
+	    nxp,mute-gpios = <&gpio0 22 GPIO_ACTIVE_LOW>;
+	    nxp,deemph-gpios = <&gpio0 29 GPIO_ACTIVE_LOW>;
+    };
 };
 
 &eth1 {
@@ -111,6 +134,7 @@ &eth2 {
 };
 
 &i2c0 {
+
 	/*
 	 * PCA9655 GPIO expander, up to 1MHz clock.
 	 *  0-CON3 CLKREQ#
diff --git a/arch/arm/boot/dts/armada-38x.dtsi b/arch/arm/boot/dts/armada-38x.dtsi
index 9b1a24cc5..fcb7d9601 100644
--- a/arch/arm/boot/dts/armada-38x.dtsi
+++ b/arch/arm/boot/dts/armada-38x.dtsi
@@ -289,6 +289,18 @@ sata3_pins: sata-pins-3 {
 					marvell,pins = "mpp44";
 					marvell,function = "sata3";
 				};
+				
+				i2s_pins: i2s_pins {
+					marvell,pins = "mpp48", "mpp49", "mpp50",
+						       "mpp51", "mpp52", "mpp53";
+					marvell,function = "audio";
+				};
+
+				tdm_pins: tdm_pins {
+					marvell,pins = "mpp48", "mpp49", "mpp50",
+						       "mpp51", "mpp52", "mpp53";
+					marvell,function = "tdm2c";
+				};
 			};
 
 			gpio0: gpio@18100 {
@@ -606,6 +618,16 @@ nand_controller: nand-controller@d0000 {
 				status = "disabled";
 			};
 
+            tdm@b0000 {
+				compatible = "marvell,armada-380-tdm";
+				reg = <0xb0000 0x5000>, <0x18400 0xc>, <0x18730 0x4>;
+				reg-names = "tdm_regs", "pll_regs", "dco_div";
+				interrupts = <0 27 0x4>;
+				clocks = <&gateclk 25>;
+				clock-names = "gateclk";
+				status = "disabled";
+			};
+
 			sdhci: sdhci@d8000 {
 				compatible = "marvell,armada-380-sdhci";
 				reg-names = "sdhci", "mbus", "conf-sdio3";
@@ -617,6 +639,15 @@ sdhci: sdhci@d8000 {
 				mrvl,clk-delay-cycles = <0x1F>;
 				status = "disabled";
 			};
+			
+			audio_controller: audio-controller@e8000 {
+				compatible = "marvell,armada-380-audio";
+				reg = <0xe8000 0x4000>, <0x18410 0xc>, <0x18204 0x4>;
+				interrupts = <0 75 0x4>;
+				clocks = <&gateclk 0>;
+				clock-names = "internal";
+				status = "okay";
+			};
 
 			usb3_0: usb3@f0000 {
 				compatible = "marvell,armada-380-xhci";
@@ -704,4 +735,17 @@ refclk: oscillator {
 			clock-frequency = <25000000>;
 		};
 	};
+	
+	sound {
+            marvell,audio-controller = <&audio_controller>;
+	        status = "okay";
+    };
+
+    spdif_out: spdif-out {
+            compatible = "linux,spdif-dit";
+    };
+
+    spdif_in: spdif-in {
+            compatible = "linux,spdif-dir";
+    };
 };
diff --git a/sound/soc/codecs/uda1334.c b/sound/soc/codecs/uda1334.c
index 21ab8c548..f50d7d1e1 100644
--- a/sound/soc/codecs/uda1334.c
+++ b/sound/soc/codecs/uda1334.c
@@ -277,6 +277,8 @@ static int uda1334_codec_probe(struct platform_device *pdev)
 	if (ret < 0)
 		dev_err(&pdev->dev, "Failed to register component: %d\n", ret);
 
+	dev_info(&pdev->dev, "probed uda1334\n");
+
 	return ret;
 }
 
diff --git a/sound/soc/kirkwood/armada-370-db.c b/sound/soc/kirkwood/armada-370-db.c
index 8e44ae37a..bb7b92e00 100644
--- a/sound/soc/kirkwood/armada-370-db.c
+++ b/sound/soc/kirkwood/armada-370-db.c
@@ -13,7 +13,6 @@
 #include <sound/soc.h>
 #include <linux/of.h>
 #include <linux/platform_data/asoc-kirkwood.h>
-#include "../codecs/cs42l51.h"
 
 static int a370db_hw_params(struct snd_pcm_substream *substream,
 			    struct snd_pcm_hw_params *params)
@@ -33,6 +32,9 @@ static int a370db_hw_params(struct snd_pcm_substream *substream,
 	case 96000:
 		freq = 24576000;
 		break;
+	case 192000:
+		freq = 49152000;
+		break;
 	}
 
 	return snd_soc_dai_set_sysclk(codec_dai, 0, freq, SND_SOC_CLOCK_IN);
@@ -51,12 +53,12 @@ static const struct snd_soc_dapm_route a370db_route[] = {
 	{ "Out Jack",	NULL,	"HPL" },
 	{ "Out Jack",	NULL,	"HPR" },
 	{ "AIN1L",	NULL,	"In Jack" },
-	{ "AIN1L",	NULL,	"In Jack" },
+	{ "AIN1R",	NULL,	"In Jack" },
 };
 
 SND_SOC_DAILINK_DEFS(analog,
 	DAILINK_COMP_ARRAY(COMP_CPU("i2s")),
-	DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "cs42l51-hifi")),
+	DAILINK_COMP_ARRAY(COMP_CODEC(NULL, "uda1334-hifi")),
 	DAILINK_COMP_ARRAY(COMP_EMPTY()));
 
 SND_SOC_DAILINK_DEFS(spdif_out,
@@ -71,7 +73,7 @@ SND_SOC_DAILINK_DEFS(spdif_in,
 
 static struct snd_soc_dai_link a370db_dai[] = {
 {
-	.name = "CS42L51",
+	.name = "UDA1334",
 	.stream_name = "analog",
 	.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS,
 	.ops = &a370db_ops,
@@ -92,7 +94,7 @@ static struct snd_soc_dai_link a370db_dai[] = {
 };
 
 static struct snd_soc_card a370db = {
-	.name = "a370db",
+	.name = "a370db/385db",
 	.owner = THIS_MODULE,
 	.dai_link = a370db_dai,
 	.num_links = ARRAY_SIZE(a370db_dai),
@@ -131,26 +133,29 @@ static int a370db_probe(struct platform_device *pdev)
 		of_parse_phandle(pdev->dev.of_node,
 				 "marvell,audio-codec", 2);
 
+	dev_info(&pdev->dev, "probed armada370db\n");
+
 	return devm_snd_soc_register_card(card->dev, card);
 }
 
 static const struct of_device_id a370db_dt_ids[] = {
 	{ .compatible = "marvell,a370db-audio" },
+	{ .compatible = "marvell,a385db-audio" },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, a370db_dt_ids);
 
-static struct platform_driver a370db_driver = {
+static struct platform_driver a370_a385_db_driver = {
 	.driver		= {
-		.name	= "a370db-audio",
+		.name	= "a370_a385-db-audio",
 		.of_match_table = of_match_ptr(a370db_dt_ids),
 	},
 	.probe		= a370db_probe,
 };
 
-module_platform_driver(a370db_driver);
+module_platform_driver(a370_a385_db_driver);
 
 MODULE_AUTHOR("Thomas Petazzoni <thomas.petazzoni@free-electrons.com>");
-MODULE_DESCRIPTION("ALSA SoC a370db audio client");
+MODULE_DESCRIPTION("ALSA SoC a370_a385-db audio client");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:a370db-audio");
diff --git a/sound/soc/kirkwood/kirkwood-i2s.c b/sound/soc/kirkwood/kirkwood-i2s.c
index 2a4ffe945..71521ebf5 100644
--- a/sound/soc/kirkwood/kirkwood-i2s.c
+++ b/sound/soc/kirkwood/kirkwood-i2s.c
@@ -31,6 +31,125 @@
 	(SNDRV_PCM_FMTBIT_S16_LE | \
 	 SNDRV_PCM_FMTBIT_S24_LE)
 
+/* These registers are relative to the second register region -
+ * audio pll configuration.
+ */
+#define A38X_PLL_CONF_REG0			0x0
+#define     A38X_PLL_FB_CLK_DIV_OFFSET		10
+#define     A38X_PLL_FB_CLK_DIV_MASK		0x7fc00
+#define A38X_PLL_CONF_REG1			0x4
+#define     A38X_PLL_FREQ_OFFSET_MASK		0xffff
+#define     A38X_PLL_FREQ_OFFSET_VALID		BIT(16)
+#define     A38X_PLL_SW_RESET			BIT(31)
+#define A38X_PLL_CONF_REG2			0x8
+#define     A38X_PLL_AUDIO_POSTDIV_MASK		0x7f
+
+/* Bit below belongs to SoC control register corresponding to the third
+ * register region.
+ */
+#define A38X_SPDIF_MODE_ENABLE		BIT(27)
+
+static int armada_38x_i2s_init_quirk(struct platform_device *pdev,
+				     struct kirkwood_dma_data *priv,
+				     struct snd_soc_dai_driver *dai_drv)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *mem;
+	u32 reg_val;
+	int i;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	priv->pll_config = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(priv->pll_config))
+		return -ENOMEM;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	priv->soc_control = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(priv->soc_control))
+		return -ENOMEM;
+
+	/* Select one of exceptive modes: I2S or S/PDIF */
+	reg_val = readl(priv->soc_control);
+	if (of_property_read_bool(np, "spdif-mode")) {
+		reg_val |= A38X_SPDIF_MODE_ENABLE;
+		dev_info(&pdev->dev, "using S/PDIF mode\n");
+	} else {
+		reg_val &= ~A38X_SPDIF_MODE_ENABLE;
+		dev_info(&pdev->dev, "using I2S mode\n");
+	}
+	writel(reg_val, priv->soc_control);
+
+	/* Update available rates of mclk's fs */
+	for (i = 0; i < 2; i++) {
+		dai_drv[i].playback.rates |= SNDRV_PCM_RATE_192000;
+		dai_drv[i].capture.rates |= SNDRV_PCM_RATE_192000;
+	}
+
+	return 0;
+}
+
+static inline void armada_38x_set_pll(void __iomem *base, unsigned long rate)
+{
+	u32 reg_val;
+	u16 freq_offset = 0x22b0;
+	u8 audio_postdiv, fb_clk_div = 0x1d;
+
+	/* Set frequency offset value to not valid and enable PLL reset */
+	reg_val = readl(base + A38X_PLL_CONF_REG1);
+	reg_val &= ~A38X_PLL_FREQ_OFFSET_VALID;
+	reg_val &= ~A38X_PLL_SW_RESET;
+	writel(reg_val, base + A38X_PLL_CONF_REG1);
+
+	udelay(1);
+
+	/* Update PLL parameters */
+	switch (rate) {
+	default:
+	case 44100:
+		freq_offset = 0x735;
+		fb_clk_div = 0x1b;
+		audio_postdiv = 0xc;
+		break;
+	case 48000:
+		audio_postdiv = 0xc;
+		break;
+	case 96000:
+		audio_postdiv = 0x6;
+		break;
+	case 192000:
+		audio_postdiv = 0x3;
+		break;
+	}
+
+	reg_val = readl(base + A38X_PLL_CONF_REG0);
+	reg_val &= ~A38X_PLL_FB_CLK_DIV_MASK;
+	reg_val |= (fb_clk_div << A38X_PLL_FB_CLK_DIV_OFFSET);
+	writel(reg_val, base + A38X_PLL_CONF_REG0);
+
+	reg_val = readl(base + A38X_PLL_CONF_REG2);
+	reg_val &= ~A38X_PLL_AUDIO_POSTDIV_MASK;
+	reg_val |= audio_postdiv;
+	writel(reg_val, base + A38X_PLL_CONF_REG2);
+
+	reg_val = readl(base + A38X_PLL_CONF_REG1);
+	reg_val &= ~A38X_PLL_FREQ_OFFSET_MASK;
+	reg_val |= freq_offset;
+	writel(reg_val, base + A38X_PLL_CONF_REG1);
+
+	udelay(1);
+
+	/* Disable reset */
+	reg_val |= A38X_PLL_SW_RESET;
+	writel(reg_val, base + A38X_PLL_CONF_REG1);
+
+	/* Wait 50us for PLL to lock */
+	udelay(50);
+
+	/* Restore frequency offset value validity */
+	reg_val |= A38X_PLL_FREQ_OFFSET_VALID;
+	writel(reg_val, base + A38X_PLL_CONF_REG1);
+}
+
 static int kirkwood_i2s_set_fmt(struct snd_soc_dai *cpu_dai,
 		unsigned int fmt)
 {
@@ -106,7 +225,10 @@ static void kirkwood_set_rate(struct snd_soc_dai *dai,
 		 * defined in kirkwood_i2s_dai */
 		dev_dbg(dai->dev, "%s: dco set rate = %lu\n",
 			__func__, rate);
-		kirkwood_set_dco(priv->io, rate);
+		if (priv->pll_config)
+			armada_38x_set_pll(priv->pll_config, rate);
+		else
+			kirkwood_set_dco(priv->io, rate);
 
 		clks_ctrl = KIRKWOOD_MCLK_SOURCE_DCO;
 	} else {
@@ -540,6 +662,14 @@ static int kirkwood_i2s_dev_probe(struct platform_device *pdev)
 	if (priv->irq < 0)
 		return priv->irq;
 
+	if (of_device_is_compatible(np, "marvell,armada-380-audio")) {
+		err = armada_38x_i2s_init_quirk(pdev, priv, soc_dai);
+		if (err < 0)
+			return err;
+
+		dev_info(&pdev->dev, "init kirkwood-a380\n");
+	}
+
 	if (np) {
 		priv->burst = 128;		/* might be 32 or 128 */
 	} else if (data) {
@@ -596,6 +726,8 @@ static int kirkwood_i2s_dev_probe(struct platform_device *pdev)
 
 	kirkwood_i2s_init(priv);
 
+	dev_info(&pdev->dev, "init done kirkwood-a380\n");
+
 	return 0;
 
  err_component:
@@ -623,6 +755,7 @@ static const struct of_device_id mvebu_audio_of_match[] = {
 	{ .compatible = "marvell,kirkwood-audio" },
 	{ .compatible = "marvell,dove-audio" },
 	{ .compatible = "marvell,armada370-audio" },
+	{ .compatible = "marvell,armada-380-audio" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, mvebu_audio_of_match);
diff --git a/sound/soc/kirkwood/kirkwood.h b/sound/soc/kirkwood/kirkwood.h
index a1733a6aa..79bb9aa7f 100644
--- a/sound/soc/kirkwood/kirkwood.h
+++ b/sound/soc/kirkwood/kirkwood.h
@@ -131,6 +131,8 @@
 
 struct kirkwood_dma_data {
 	void __iomem *io;
+	void __iomem *pll_config;
+	void __iomem *soc_control;
 	struct clk *clk;
 	struct clk *extclk;
 	uint32_t ctl_play;
-- 
Created with Armbian build tools https://github.com/armbian/build

